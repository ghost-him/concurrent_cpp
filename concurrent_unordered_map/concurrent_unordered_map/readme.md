> 由gemini 2.5pro preview 05-06生成

## Concurrent Unordered Map in C++

这是一个基于 C++ 实现的线程安全的哈希表（`concurrent_unordered_map`）。它采用分桶策略，并为每个桶配备独立的读写锁，以允许多线程并发访问。

### 核心设计

*   **分桶 (Bucketing):** 内部使用 `std::vector` 存储固定数量的桶。
*   **冲突处理 (Separate Chaining):** 每个桶内部使用 `std::list` 来存储可能哈希到同一桶的键值对。
*   **并发控制 (Fine-Grained Locking):**
    *   每个桶 (`bucket_type`) 拥有一个独立的 `std::shared_mutex`。
    *   读操作（`value_for`）使用共享锁 (`std::shared_lock`)，允许多个线程同时读取同一桶。
    *   写操作（`add_or_update_mapping`, `remove_mapping`）使用独占锁 (`std::unique_lock`)，确保同一时间只有一个线程修改桶。

### 时间复杂度 (平均情况，假设哈希函数良好，负载因子适中)

*   **`add_or_update_mapping(key, value)`**: O(1)
*   **`value_for(key, default_value)`**: O(1)
*   **`remove_mapping(key)`**: O(1)

*在最坏情况下（所有键哈希到同一个桶），上述操作的复杂度会退化到 O(N/M)，其中 N 是元素总数，M 是桶的数量。如果 M=1，则为 O(N)。*

*空间复杂度：O(N + M)，其中 N 是元素数量，M 是桶的数量。*

### 优点

1.  **线程安全:** 核心的增、删、查、改操作是线程安全的。
2.  **高并发性:** 采用分桶锁（每个桶一个锁）的设计，不同桶的操作可以并行执行，提高了并发性能。
3.  **读写优化:** 使用 `std::shared_mutex`，允许多个线程同时读取同一个桶的数据，适合读多写少的场景。
4.  **RAII资源管理:** 通过 `std::unique_ptr` 管理桶的生命周期，通过锁守卫（`std::unique_lock`, `std::shared_lock`）确保锁的正确释放，即使发生异常。
5.  **接口简洁:** 提供与标准库类似的基本哈希表操作。
6.  **禁止拷贝/赋值:** 默认删除了拷贝构造和赋值操作，避免了并发容器拷贝的复杂性和潜在风险。

### 缺点

1.  **固定桶数量:** 桶的数量在构造时确定，不支持动态调整（rehashing）。如果初始桶数量设置不当或数据量远超预期，可能导致某些桶链表过长，性能下降。
2.  **潜在的哈希热点:** 若哈希函数分布不均，或特定键被频繁访问，可能导致对应桶的锁竞争激烈，影响性能。
3.  **桶内线性查找:** 当单个桶内元素过多时，桶内查找（基于`std::list`）为线性扫描，效率降低。
4.  **无全局信息接口:** 未提供如 `size()`、`empty()` 或遍历整个哈希表的迭代器等全局操作（这些操作在并发环境下实现通常代价较高或难以保证一致性）。
