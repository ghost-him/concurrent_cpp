参考视频：https://www.bilibili.com/video/BV1Re411a7vT
参考文档：https://gitbookcpp.llfc.club/sections/cpp/concurrent/concpp24.html

> 以下的内容使用 Gemini 2.5 pro 生成

## 什么是 Actor 模式？

Actor 模式是一种并发计算的数学模型和编程范式。它将“Actor”作为并发的基本单元，彻底改变了传统基于线程和锁（Thread & Lock）的并发编程方式。

可以把一个 Actor 想象成一个独立的、有生命的人（或一个微服务）：

1.  **拥有私有状态（State）**：每个 Actor 都有自己的内部数据，这些数据是完全私有的，任何其他 Actor 都不能直接访问或修改它。这从根本上杜绝了数据竞争（Data Race）。
2.  **通过消息通信（Communication）**：Actor 之间不共享内存，它们唯一的交互方式是互相发送**异步**、**不可变**的消息。就像人们通过邮箱收发信件一样。
3.  **处理消息（Processing）**：每个 Actor 都有一个邮箱（Mailbox），用于接收发来的消息。它按顺序从邮箱中取出一条消息进行处理。

当一个 Actor 接收到一条消息时，它可以做以下三件事之一：

*   **创建新的 Actor**：可以衍生出更多的 Actor 来分担工作。
*   **向其他 Actor 发送消息**：可以给它认识的 Actor（通过地址）发送消息。
*   **改变自己的内部状态**：可以修改自己的私有数据，为下一条消息的处理做准备。



**核心思想**：**万物皆 Actor (Everything is an Actor)**。通过将状态封装在 Actor 内部，并将所有交互都变成异步消息传递，从而避免了共享状态和锁，这是并发编程中最主要的复杂性和错误来源。

## 与传统 C++ 并发模型（`std::thread`, `std::mutex`）的对比

| 特性 | 传统模型 (`std::thread` + `std::mutex`) | Actor 模式 |
| :--- | :--- | :--- |
| **核心** | **共享内存，显式加锁** | **无共享状态，消息传递** |
| **并发单元** | 线程 (Thread) | Actor |
| **数据保护** | 互斥锁 (Mutex), 条件变量 (CV), 原子操作 | **封装**。状态是 Actor 私有的，天然线程安全。 |
| **通信方式** | 直接方法调用，通过共享内存读写数据 | **异步消息传递** |
| **主要挑战** | **死锁 (Deadlock)**, **活锁 (Livelock)**, **数据竞争 (Data Race)**, 复杂的锁策略 | 异步逻辑的思维转换，消息流的管理，调试（调用栈不直观） |
| **代码风格** | 命令式，同步调用为主 | 事件驱动，异步回调/处理函数 |

## 2. 使用 C++ Actor 框架

手动实现很适合学习，但在真实项目中，推荐使用成熟的库，它们提供了更多高级功能：

*   **高效的调度器**：通常使用线程池来管理成千上万个 Actor，而不是一个 Actor 一个线程。
*   **类型安全的消息**：在编译期检查消息类型，防止发送错误的消息。
*   **错误处理与监督 (Supervision)**：一个 Actor 失败时，其父 Actor (Supervisor) 可以决定是重启它、忽略错误还是让错误升级。这是构建健壮系统的关键。
*   **网络透明性**：可以向本地或远程机器上的 Actor 发送消息，代码几乎一样。
*   **路由、分发等模式**。

**流行的 C++ Actor 库：**

1.  **CAF (C++ Actor Framework)**：目前最成熟、功能最全面的 C++ Actor 库。它提供了类型安全的消息传递、强大的运行时检查、网络透明性和灵活的 Actor 类型（静态类型 vs. 动态类型）。
2.  **SObjectizer**：另一个历史悠久且非常稳定的 Actor 框架。它在设计理念上有些许不同，但同样强大。
3.  **rotor**：一个较新的库，设计现代，注重性能和可扩展性。

## 总结

### 优点

*   **无锁并发**：从根本上避免了死锁和数据竞争，极大地简化了并发逻辑。
*   **高并发和可伸缩性**：Actor 是轻量级单元，一个系统可以轻松支持成千上万个 Actor。调度器可以有效地将它们映射到少量线程上。
*   **封装和解耦**：Actor 之间是松耦合的，只通过消息接口交互，易于测试和维护。
*   **天然的容错性**：监督树机制使得构建能够自我修复的系统成为可能。
*   **位置透明性**：无论是本地还是远程 Actor，通信方式都一样，便于构建分布式系统。

### 缺点

*   **思维模式转变**：对于习惯了同步、命令式编程的开发者来说，全异步、事件驱动的编程方式需要一个适应过程。
*   **调试困难**：由于操作是异步的，传统的调用栈（Call Stack）在调试时作用有限。需要依赖日志和专门的调试工具来追踪消息流。
*   **性能开销**：消息传递相比直接的方法调用会有一些性能开销（虽然现代框架优化得很好）。不适合所有场景，尤其是一些性能极致的计算密集型任务。
*   **无原生支持**：需要引入第三方库，增加了项目的依赖和学习成本。

总而言之，Actor 模式是 C++ 中一种强大而优雅的并发编程范式，特别适合构建复杂的、高并发的、需要长期稳定运行的系统，例如服务器后端、网络服务、物联网（IoT）网关等。它通过牺牲一点点性能和改变编程习惯，换来了并发逻辑的极大简化和系统的可维护性与健壮性。